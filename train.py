import pandas as pd
import numpy as np
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import _tree

# --- 1. Load the Generated Dataset ---
print("Loading real-world URL dataset...")
try:
    df = pd.read_csv("url_dataset.csv")
    print(f"Successfully loaded {len(df)} URLs.")
except FileNotFoundError:
    print("Error: 'url_dataset.csv' not found. Run 'python get_data.py' first.")
    exit()

df = df.dropna(subset=['url', 'label'])

# --- 2. Feature Extraction ---
print("Extracting hardware-compatible features...")
def extract_features(url):
    url_str = str(url)
    f0 = len(url_str)                     # Feature 0: Length
    f1 = sum(c.isdigit() for c in url_str) # Feature 1: Digit count
    f2 = url_str.count('-')               # Feature 2: Hyphen count
    return [f0, f1, f2]

features = np.array(df['url'].apply(extract_features).tolist())
labels = df['label'].values

# --- 3. Train the Low-Latency Decision Tree ---
print("Training the Decision Tree...")
clf = DecisionTreeClassifier(max_depth=4, random_state=42)
clf.fit(features, labels)

accuracy = clf.score(features, labels)
print(f"Model Training Complete. Accuracy on dataset: {accuracy * 100:.2f}%")

# --- 4. The C++ Transpiler (With Lowercase Boolean Fix) ---
def build_cpp_header(tree, filename="decision_tree.h"):
    print(f"Transpiling model to native C++ logic ({filename})...")
    tree_ = tree.tree_
    
    cpp_code = "#ifndef DECISION_TREE_H\n#define DECISION_TREE_H\n\n"
    cpp_code += "// AUTO-GENERATED BY PYTHON: DO NOT EDIT MANUALLY\n"
    cpp_code += "inline bool evaluate_model(int f0, int f1, int f2) {\n"
    
    def recurse(node, depth):
        nonlocal cpp_code
        indent = "  " * (depth + 1)
        if tree_.feature[node] != _tree.TREE_UNDEFINED:
            name = f"f{tree_.feature[node]}"
            threshold = tree_.threshold[node]
            cpp_code += f"{indent}if ({name} <= {threshold}) {{\n"
            recurse(tree_.children_left[node], depth + 1)
            cpp_code += f"{indent}}} else {{\n"
            recurse(tree_.children_right[node], depth + 1)
            cpp_code += f"{indent}}}\n"
        else:
            class_idx = np.argmax(tree_.value[node][0])
            # Guaranteed C++ compatible lowercase booleans
            cpp_boolean = "true" if class_idx == 1 else "false"
            cpp_code += f"{indent}return {cpp_boolean};\n"
            
    recurse(0, 0)
    cpp_code += "}\n\n#endif\n"
    
    with open(filename, "w") as f:
        f.write(cpp_code)
    print("Transpilation successful. Ready for C++ compilation.")

build_cpp_header(clf)